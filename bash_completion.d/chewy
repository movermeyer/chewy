#
# Bash command line completer for `chewy`
#


_guess_modules_dir()
{
    local curdir=$1

    if [ -z "${curdir}" -o "${curdir}" = "/" ]; then
        modules_dir=
    elif [ -d "${curdir}/cmake/modules" ]; then
        modules_dir="${curdir}/cmake/modules"
    elif [ -d "${curdir}/cmake" ]; then
        modules_dir="${curdir}/cmake"
    else
        _guess_modules_dir `dirname "${curdir}"`
    fi
}

_get_modules_dir_and_command()
{
    local i
    local next=
    modules_dir=
    for (( i=1; i < cword; i++ )); do
        if [ -z "${next}" ]; then
            if [ "${COMP_WORDS[i]}" = "-m" -o "${COMP_WORDS[i]}" = "--modules-dir" ]; then
                next="modules-dir"
                continue
            else
                cmd=${COMP_WORDS[i]}
                break
            fi
        elif [ "${next}" = "modules-dir" ]; then
            modules_dir=${COMP_WORDS[i]}
            next="command"
            continue
        elif [ "${next}" = "command" ]; then
            cmd=${COMP_WORDS[i]}
            break
        else
            echo "chewy error: Invalid command line"
            return 1
        fi
    done
    if [ -z "${modules_dir}" ]; then
        _guess_modules_dir `pwd`
    fi
}

_get_repobases_started_with()
{
    local starts_with=$1
    # Return full repobase paths
    repolist=`grep --color=none -nr "X-Chewy-RepoBase: ${starts_with}" "${modules_dir}/"*.cmake \
        | sed "s,.*X-Chewy-RepoBase:\s*\(${starts_with}.*\)\s*$,\1," \
        | sort \
        | uniq \
        `
}

_chewy()
{
    local _chewy_commands="get list status update"
    local _chewy_long_opts="--modules-dir"
    local _chewy_short_opts="-m"

    COMPREPLY=()
    _get_comp_words_by_ref -n ':' cur prev words cword

    cmd=
    modules_dir=
    if [ ${#words[@]} -ge 1 ]; then
        _get_modules_dir_and_command
    fi

    case "$prev" in
    chewy)
        COMPREPLY=( $(compgen -W "${_chewy_long_opts} ${_chewy_short_opts} ${_chewy_commands}" \
            -- ${cur}) )
        ;;
    -m | --modules-dir)
        _filedir -d
        ;;
    *)
        if [ -z "${cmd}" ]; then
            COMPREPLY=( $(compgen -W "${_chewy_commands}" \
                -- ${cur}) )
            return
        fi
        case "$cmd" in
        get | list)
            compopt -o nospace
            if [ -n "${modules_dir}" ]; then
                _get_repobases_started_with "${cur}"
            fi
            if [ "${cur}" != "http://" -o "${cur}" != "https://" ]; then
                compopt +o nospace
            fi
            COMPREPLY=( $(compgen -o nospace -W "http:// https:// ${repolist}" \
                -- "${cur}") )
            __ltrim_colon_completions ${cur}
            ;;
        status | update)
            # If modules-dir found, change current dir temporary...
            if [ -n "${modules_dir}" ]; then
                cd ${modules_dir}
            fi
            # TODO Is it reasonable to find a real chewy modules and complete only
            # them instead of all files?
            _filedir cmake
            if [ -n "${modules_dir}" ]; then
                cd - >/dev/null
            fi
            ;;
        esac
        ;;
    esac
}

complete -F _chewy chewy
# kate: hl bash;
