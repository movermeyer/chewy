#!/usr/bin/env python
#
# -*- coding: utf-8 -*-
#

import argparse
import portage.output
import os
import sys
import urllib.parse

# TODO This doesn't needed for installed package
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import chewy
import chewy.session

log = portage.output.EOutput()


def rcv_manifests(repobase_list):
    # Retrieve manifests for all used chewy repositories
    manifest_map = {}
    with chewy.session.Factory() as sf:
        for repobase in repobase_list:
            if repobase not in manifest_map:                   # Manifest still not retrieved
                ep = chewy.HttpEndpoint(repobase)
                manifest_map[repobase] = sf.get_session(ep).get_manifest()
    return manifest_map



# TODO If no repo given, try to find a modules base,
# scan it and collect used repo bases...?
def do_list(url_list):
    '''Execute `list' command'''
    if not url_list:
        log.eerror('At least one repository URL should be given')
    # Make URLs unique
    urls = set(url_list)

    for repobase, manifest in rcv_manifests(urls).items():
        log.einfo("Modules from the `{}' repository".format(repobase))
        print(chewy.FancyGrid(
            [ [mod.path, mod.version, mod.description] for mod in manifest.modules ]
          ))



def do_get(url_list, modules_dir):
    '''Execute `get' command'''
    if not url_list:
        log.eerror('At least one url should be passed')

    with chewy.session.Factory() as sf:
        for url in url_list:
            try:
                ep = chewy.HttpEndpoint(url)
                cs = sf.get_session(ep)
                log.einfo('Get module {}'.format(url))
                data = cs.retrieve_remote_file(ep.geturl())             # Get a remote file into string

                # Going to write just received data to the modules dir
                o = urllib.parse.urlsplit(url)
                os.makedirs(
                    os.path.join(
                        modules_dir
                      , os.path.dirname(o.path).strip('/')
                      )
                  , exist_ok=True
                  )
                # TODO: Strip repobasename
                with open(os.path.join(modules_dir, o.path.strip('/')), 'wt', encoding = 'utf-8') as f:
                    f.write(data)
                    # TODO Retrieve dependencies according manifest
                    # TODO Version compare required as well
            # TODO pass 'can't create modules dir' exception through
            except RuntimeError as ex:
                log.eerror("Can't get {} file: {}".format(url, ex))


def do_status(modules_dir):
    '''Execute `status' command'''

    # Get modules installed in a given dir
    status_map = chewy.collect_installed_modules(modules_dir)

    # Retrieve remote_modules_map for all used chewy repositories
    manifests_map = rcv_manifests(status_map.keys())

    # Iterate over installed modules (statuses actually) grouped by repository
    for repobase, modules in status_map.items():
        # Iterate over list of module statuses
        for status in modules:
            local_mod = status.module
            # Find local module in a remote repository
            remote_mod = chewy.find(manifests_map[repobase].modules, lambda x: x.path == local_mod.path)
            # If not found, mark current module as deleted
            if not remote_mod:
                status.set_remote_version(None)
            else:
                assert(remote_mod.path == local_mod.path)
                # Remember the remote version
                status.set_remote_version(remote_mod.version)

    # Group by unique repobase
    for repobase in status_map:
        log.einfo('List of {}'.format(repobase))
        # TODO Colorise output (especially new versions)
        print(
            chewy.FancyGrid([
                [
                    m.status_as_string()
                  , m.module.path
                  , m.module.version
                  , m.available_version()
                  , m.module.description
                ]
                for m in status_map[repobase]
              ])
          )


def do_update(modules_dir):
    '''Execute `update' command'''

    # Get modules installed in a given dir
    status_map = chewy.collect_installed_modules(modules_dir)

    # Retrieve remote_modules_map for all used chewy repositories
    manifest_map = rcv_manifests(status_map.keys())

    assert(
        'We expect to receive same number of manifests as different repositories we are subscribed to'
        'Or less if some error during receiving occured'
       and len(status_map) >= len(manifest_map)
      )

    for repobase in status_map:
        log.einfo('Updating {} repository'.format(repobase))
        # TODO: Check we didn't fault some manifests receiving by network problems
        assert(repobase in manifest_map)
        matched_modules = [ mod.module for mod in status_map[repobase] if mod.module in manifest_map[repobase].modules ]

        try:
            pass
        except RuntimeError as ex:
            log.einfo('Error: {}'.format(ex))
            continue




def main():
    cmd_parser = argparse.ArgumentParser(description='Manage the project specific CMake modules')
    cmd_parser.add_argument(
        '-m'
      , '--modules-dir'
      , metavar='PATH'
      , help='CMake modules directory to operate with'
      )

    subparsers = cmd_parser.add_subparsers(help='Available sub-commands:', dest='cmd')

    list_parser = subparsers.add_parser(
        'list'
      , help='Repositories URI list. Empty list means to get a list of all'
        'repositories which are founded in installed files'
      )
    get_parser = subparsers.add_parser(
        'get'
      , help='Get file from repository and add it to the project as new one'
      )
    update_parser = subparsers.add_parser(
        'update'
      , help='Update [all] installed files from their repo-sources'
      )
    status_parser = subparsers.add_parser('status', help='Check status of [all] installed files')

    list_parser.add_argument('rep_url', metavar='REPO-URL', help='Repositories URL list', nargs='*')
    get_parser.add_argument('file_url', metavar='FILE-URL', help='Files URL list', nargs='+')
    update_parser.add_argument(
        'file_url'
      , metavar='FILE-URL'
      , help='Files URI list. Empty list means to update all installed files'
      , nargs='*'
      )
    status_parser.add_argument(
        'file_url'
      , metavar='FILE-URL'
      , help='Files URI list. Empty list means to check status of all installed files'
      , nargs='*'
      )

    args = cmd_parser.parse_args()

    if args.cmd == 'list':
        # To get a list of modules, the working directory is not required
        do_list(args.rep_url)
    else:
        # Initialize working directory
        if args.modules_dir:
            if os.path.isdir(args.modules_dir):
                modules_dir = args.modules_dir
            else:
                log.eerror("Unable to find CMake modules directory `{}'".format(chewy.EXPECTED_CMAKE_MODULES_PATH))
                sys.exit(1)
        else:
            try:
                modules_dir = chewy.modules_dir_lookup()
            except RuntimeError as e:
                log.eerror(e.args[0])
                sys.exit(1)

        # Continue to dispatch a command...
        if args.cmd == 'get':
            do_get(args.file_url, modules_dir)
        elif args.cmd == 'status':
            do_status(modules_dir)
        elif args.cmd == 'update':
            do_update(modules_dir)

    # Done!
    sys.exit(0)


if __name__ == "__main__":
    main()
