#!/usr/bin/env python
#
# -*- coding: utf-8 -*-
#

import argparse
import portage.output
import os
import sys
import urllib.parse

# TODO This doesn't needed for installed package
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import chewy

log = portage.output.EOutput()


def do_list(url_list):
    '''Execute `list' command'''
    if not url_list:
        log.eerror('At least one repository URL should be given')
    # Make URLs unique
    urls = set(url_list)

    result = {}
    with chewy.session_factory() as sf:
        for url in urls:
            ep = chewy.http_endpoint(url)
            result[url] = sf.get_session(ep).get_manifest()

    # remove repository name
    current_repo = None
    for repo in result:
        for rec in result[repo]:
            rec[2] = urllib.parse.unquote_plus(rec[2])

    for repo in result:
        log.einfo("Modules from the `{}' repository".format(repo))
        print(chewy.fancy_grid(result[repo]))



def do_get(url_list):
    if not url_list:
        log.eerror('At least one url should be passed')

    with chewy.session_factory() as sf:
        for url in url_list:
            try:
                ep = chewy.http_endpoint(url)
                cs = sf.get_session(ep)
                log.einfo('Get module {}'.format(url))
                data = cs.retrieve_remote_file(ep.geturl())             # Get a remote file into string

                # Going to write just received data to the modules dir
                o = urllib.parse.urlsplit(url)
                os.makedirs(
                    os.path.join(
                        modules_dir
                      , os.path.dirname(o.path).strip('/')
                      )
                  , exist_ok=True
                  )
                # TODO: Strip repobasename
                with open(os.path.join(modules_dir, o.path.strip('/')), 'wt', encoding = 'utf-8') as f:
                    f.write(data)
                    # TODO Retrieve dependencies according manifest
                    # TODO Version compare required as well
            # TODO pass 'can't create modules dir' exception through
            except RuntimeError as ex:
                log.eerror("Can't get {} file: {}".format(url, ex))


def main():
    cmd_parser = argparse.ArgumentParser(description='Manage the project specific CMake modules')
    cmd_parser.add_argument(
        '-m'
      , '--modules-dir'
      , metavar='PATH'
      , help='CMake modules directory to operate with'
      )

    subparsers = cmd_parser.add_subparsers(help='Available sub-commands:', dest='cmd')

    list_parser = subparsers.add_parser(
        'list'
      , help='Repositories URI list. Empty list means to get a list of all'
        'repositories which are founded in installed files'
      )
    get_parser = subparsers.add_parser(
        'get'
      , help='Get file from repository and add it to the project as new one'
      )
    update_parser = subparsers.add_parser(
        'update'
      , help='Update [all] installed files from their repo-sources'
      )
    status_parser = subparsers.add_parser('status', help='Check status of [all] installed files')

    list_parser.add_argument('rep_url', metavar='REPO-URL', help='Repositories URL list', nargs='*')
    get_parser.add_argument('file_url', metavar='FILE-URL', help='Files URL list', nargs='+')
    update_parser.add_argument(
        'file_url'
      , metavar='FILE-URL'
      , help='Files URI list. Empty list means to update all installed files'
      , nargs='*'
      )
    status_parser.add_argument(
        'file_url'
      , metavar='FILE-URL'
      , help='Files URI list. Empty list means to check status of all installed files'
      , nargs='*'
      )

    args = cmd_parser.parse_args()

    if args.cmd == 'list':
        # To get a list of modules, the working directory is not required
        do_list(args.rep_url)
    else:
        global modules_dir
        # Initialize working directory
        if args.modules_dir:
            if os.path.isdir(args.modules_dir):
                modules_dir = args.modules_dir
            else:
                log.eerror("Unable to find CMake modules directory `{}'".format(chewy.EXPECTED_CMAKE_MODULES_PATH))
                sys.exit(1)
        else:
            # TODO Can throw!
            modules_dir = modules_dir_lookup()

        # Continue to dispatch a command...
        if args.cmd == 'get':
            do_get(args.file_url)
        elif args.cmd == 'status':
            # Group installed modules by unique repobase
            # dict<list<Modules>, status, remote_version>
            mod_list = {}
            for file in chewy.modules_lookup(modules_dir):
                try:
                    with open(file, 'rt') as f:
                        content = f.read()
                        mod = chewy.Module(content)
                        if not mod.repobase in mod_list:
                            mod_list[mod.repobase] = []
                        mod_list[mod.repobase].append([mod, '', None])
                except chewy.NoMetaError:
                    continue

            result = {}
            with chewy.session_factory() as sf:
                for rep in mod_list.keys():
                    ep = chewy.http_endpoint(rep)
                    result[rep] = sf.get_session(ep).get_manifest()

            for repbase in mod_list:
                for mod_status_pair in mod_list[repbase]:
                    local_mod = mod_status_pair[0]
                    remote_mod = next(filter(lambda x: local_mod.path == x.path, result[repbase].modules), None)
                    if not remote_mod:
                        mod_status_pair[1] = 'D'
                        continue

                    assert(remote_mod.path == local_mod.path)
                    mod_status_pair[2] = remote_mod.version
                    if remote_mod.version > local_mod.version:
                        mod_status_pair[1] = 'U'
                    elif local_mod.version > remote_mod.version:
                        mod_status_pair[1] = 'M'
                    else:
                        # TODO: Remove from output
                        mod_status_pair[1] = '*'
                    continue

            # Group by unique repobase
            for repobase in mod_list:
                log.einfo('List of {}'.format(repobase))
                print(chewy.fancy_grid([
                  [m[1], m[0].path, m[0].version, m[2], m[0].description]
                  for m in mod_list[repobase]
                  ]))

            #for repo in result:
            #    log.einfo("Modules from the `{}' repository".format(repo))
            #    print(chewy.fancy_grid(result[repo]))
            # TODO: rcv manifest and check status
            #mod.version
            #mod.repobase
            #mod.path
            #mod.description
            #mod.addons

        elif args.cmd == 'update':
            pass



if __name__ == "__main__":
    main()
