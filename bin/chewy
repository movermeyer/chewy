#!/usr/bin/env python
#
# -*- coding: utf-8 -*-
#

import sys
import os

# TODO This doesn't needed for installed package
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import chewy
import chewy.session

import argparse
import portage.output
import urllib.parse
import tempfile
import shutil



log = portage.output.EOutput()

class PathError(RuntimeError):
    pass


def sandbox_path(prefix, path):
    assert(
        'We expect prefix is an absolute path in the function by security reason'
        and prefix == os.path.abspath(prefix)
      )
    abspath = os.path.abspath(os.path.join(prefix, path))
    if not abspath.startswith(prefix):
        raise PathError(
            'Relative pathname {} trying to pass the sandbox {}'.format(path, abspath)
          )
    return abspath


# TODO: shutil.copytree can't copy to existed destenition. We need the own analogue
#def copytree(src, dst, symlinks=False, ignore=None):
#    for item in os.listdir(src):
#        if os.path.
#        for i in os.listdir(dst):
#            s = os.path.join(src, item)
#            d = os.path.join(dst, item)
#            if os.path.isdir(s):
#                shutil.copytree(s, d, symlinks, ignore, copy_function=shutil.copy)
#            else:
#                shutil.copy(s, d)


def uninstall(modules_dir, mod):
    '''
        Uninstall the chewy module and all related files
        Note uninstall doesn't clean empty directories possible after uninstall process
    '''
    for path in [ os.path.join(modules_dir, f) for f in mod.addons ]:
        abspath = sandbox_path(modules_dir, path)
        if os.path.exists(abspath):
            os.unlink(abspath)


def rcv_manifests(repobase_list):
    # Retrieve manifests for all used chewy repositories
    manifest_map = {}
    with chewy.session.Factory() as sf:
        for repobase in repobase_list:
            if repobase not in manifest_map:                   # Manifest still not retrieved
                ep = chewy.HttpEndpoint(repobase)
                manifest_map[repobase] = sf.get_session(ep).get_manifest()
    return manifest_map



# TODO If no repo given, try to find a modules base,
# scan it and collect used repo bases...?
def do_list(url_list):
    '''Execute `list' command'''
    if not url_list:
        log.eerror('At least one repository URL should be given')
    # Make URLs unique
    urls = set(url_list)

    for repobase, manifest in rcv_manifests(urls).items():
        log.einfo("Modules from the `{}' repository".format(repobase))
        print(chewy.FancyGrid(
            [ [mod.path, mod.version, mod.description] for mod in manifest.modules ]
          ))


def rcv_module(mod, modules_dir, sf, uninst=False):
    with tempfile.TemporaryDirectory() as tmpdirname:
        # Doesn't catch any exception because any error means module receiving is fall
        for relpath in mod.addons:
            url = os.path.join(mod.repobase, relpath)
            ep = chewy.HttpEndpoint(url)
            cs = sf.get_session(ep)
            log.einfo('Get file {}'.format(url))
            data = cs.retrieve_remote_file(ep.geturl())             # Get a remote file into string

            abs_tmp_path = sandbox_path(tmpdirname, relpath)

            # Create necessary temporary directorie's sub tree
            os.makedirs(
                os.path.dirname(abs_tmp_path).strip('/')
              , exist_ok=True
              )

            # Going to write just received data to the temporary dir
            # TODO: Strip repobasename
            with open(abs_tmp_path, 'wt', encoding = 'utf-8') as f:
                f.write(data)
                # TODO: Version compare is required as well. Is it?
        if not uninst:
            uninstall(modules_dir, mod)
        shutil.copytree(tmpdirname, modules_dir)


def do_get(url_list, modules_dir):
    '''Execute `get' command'''
    if not url_list:
        log.eerror('At least one url should be passed')

    with chewy.session.Factory() as sf:
        for url in url_list:
            try:
                ep = chewy.HttpEndpoint(url)
                cs = sf.get_session(ep)
                log.einfo('Get module {}'.format(url))
                data = cs.retrieve_remote_file(ep.geturl())             # Get a remote file into string
                mod = chewy.Module(data)
                rcv_module(mod, modules_dir, sf)

            # TODO pass 'can't create modules dir' exception through
            except RuntimeError as ex:
                log.eerror("Can't get {} file: {}".format(url, ex))


def do_status(modules_dir):
    '''Execute `status' command'''

    # Get modules installed in a given dir
    status_map = chewy.collect_installed_modules(modules_dir)

    # Retrieve remote_modules_map for all used chewy repositories
    manifests_map = rcv_manifests(status_map.keys())

    # Iterate over installed modules (statuses actually) grouped by repository
    for repobase, modules in status_map.items():
        # Iterate over list of module statuses
        for status in modules:
            local_mod = status.module
            # Find local module in a remote repository
            remote_mod = chewy.find(manifests_map[repobase].modules, lambda x: x.path == local_mod.path)
            # If not found, mark current module as deleted
            if not remote_mod:
                status.set_remote_version(None)
            else:
                assert(remote_mod.path == local_mod.path)
                # Remember the remote version
                status.set_remote_version(remote_mod.version)

    # Group by unique repobase
    for repobase in status_map:
        log.einfo('List of {}'.format(repobase))
        # TODO Colorise output (especially new versions)
        print(
            chewy.FancyGrid([
                [
                    m.status_as_string()
                  , m.module.path
                  , m.module.version
                  , m.available_version()
                  , m.module.description
                ]
                for m in status_map[repobase]
              ])
          )


def do_update(modules_dir):
    '''Execute `update' command'''

    # Get modules installed in a given dir
    status_map = chewy.collect_installed_modules(modules_dir)

    # Retrieve remote_modules_map for all used chewy repositories
    manifest_map = rcv_manifests(status_map.keys())

    assert(
        'We expect to receive same number of manifests as different repositories we are subscribed to'
        'Or less if some error during receiving occured'
       and len(status_map) >= len(manifest_map)
      )

    for repobase in status_map:
        log.einfo('Updating {} repository'.format(repobase))
        # TODO: Check we didn't fault some manifests receiving by network problems
        assert(repobase in manifest_map)
        matched_modules = [ mod.module for mod in status_map[repobase] if mod.module in manifest_map[repobase].modules ]

        try:
            pass
        except RuntimeError as ex:
            log.einfo('Error: {}'.format(ex))
            continue




def main():
    cmd_parser = argparse.ArgumentParser(description='Manage the project specific CMake modules')
    cmd_parser.add_argument(
        '-m'
      , '--modules-dir'
      , metavar='PATH'
      , help='CMake modules directory to operate with'
      )

    subparsers = cmd_parser.add_subparsers(help='Available sub-commands:', dest='cmd')

    list_parser = subparsers.add_parser(
        'list'
      , help='Repositories URI list. Empty list means to get a list of all'
        'repositories which are founded in installed files'
      )
    get_parser = subparsers.add_parser(
        'get'
      , help='Get file from repository and add it to the project as new one'
      )
    update_parser = subparsers.add_parser(
        'update'
      , help='Update [all] installed files from their repo-sources'
      )
    status_parser = subparsers.add_parser('status', help='Check status of [all] installed files')

    list_parser.add_argument('rep_url', metavar='REPO-URL', help='Repositories URL list', nargs='*')
    get_parser.add_argument('file_url', metavar='FILE-URL', help='Files URL list', nargs='+')
    update_parser.add_argument(
        'file_url'
      , metavar='FILE-URL'
      , help='Files URI list. Empty list means to update all installed files'
      , nargs='*'
      )
    status_parser.add_argument(
        'file_url'
      , metavar='FILE-URL'
      , help='Files URI list. Empty list means to check status of all installed files'
      , nargs='*'
      )

    args = cmd_parser.parse_args()

    if args.cmd == 'list':
        # To get a list of modules, the working directory is not required
        do_list(args.rep_url)
    else:
        # Initialize working directory
        if args.modules_dir:
            if os.path.isdir(args.modules_dir):
                modules_dir = args.modules_dir
            else:
                log.eerror("Unable to find CMake modules directory `{}'".format(chewy.EXPECTED_CMAKE_MODULES_PATH))
                sys.exit(1)
        else:
            try:
                modules_dir = chewy.modules_dir_lookup()
            except RuntimeError as e:
                log.eerror(e.args[0])
                sys.exit(1)

        # Continue to dispatch a command...
        if args.cmd == 'get':
            do_get(args.file_url, modules_dir)
        elif args.cmd == 'status':
            do_status(modules_dir)
        elif args.cmd == 'update':
            do_update(modules_dir)

    # Done!
    sys.exit(0)


if __name__ == "__main__":
    main()
